package com.weatherapp\n\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.MutableLiveData\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.viewModelScope\nimport com.weatherapp.api.WeatherApiService\nimport com.weatherapp.model.WeatherResponse\nimport kotlinx.coroutines.launch\n\n/**\n * WeatherViewModel handles the logic for fetching weather data and exposing it to the UI.\n * It interacts with WeatherRepository to get data and uses LiveData to notify UI of changes.\n */\nclass WeatherViewModel(private val repository: WeatherRepository) : ViewModel() {\n\n    // MutableLiveData for holding weather data, exposed as immutable LiveData to UI\n    private val _weatherData = MutableLiveData<WeatherResponse?>()\n    val weatherData: LiveData<WeatherResponse?> = _weatherData\n\n    // MutableLiveData for managing loading state\n    private val _isLoading = MutableLiveData<Boolean>()\n    val isLoading: LiveData<Boolean> = _isLoading\n\n    // MutableLiveData for handling error messages\n    private val _errorMessage = MutableLiveData<String?>()\n    val errorMessage: LiveData<String?> = _errorMessage\n\n    /**\n     * Fetches weather data for a given city asynchronously using coroutines.\n     * Updates LiveData with success, loading, or error states.\n     */\n    fun fetchWeather(city: String) {\n        _isLoading.value = true // Set loading state to true\n        _errorMessage.value = null // Clear any previous error message\n        viewModelScope.launch { // Launch a coroutine in the ViewModel's scope\n            try {\n                val response = repository.getWeather(city) // Make API call via repository\n                if (response.isSuccessful) {\n                    _weatherData.value = response.body() // Update data on success\n                } else {\n                    // Handle API error responses (e.g., 404, 500)\n                    _errorMessage.value = "Chyba: ${response.code()} ${response.message()}"\n                    _weatherData.value = null // Clear previous data on error\n                }\n            } catch (e: Exception) {\n                // Handle network or other exceptions\n                _errorMessage.value = "Chyba sítě: ${e.localizedMessage ?: "Neznámá chyba"}"\n                _weatherData.value = null // Clear previous data on error\n            } finally {\n                _isLoading.value = false // Always set loading to false when operation completes\n            }\n        }\n    }\n\n    /**\n     * Factory for creating WeatherViewModel instances with dependencies.\n     * This is necessary because ViewModel has a constructor argument (WeatherRepository).\n     */\n    class Factory(private val apiService: WeatherApiService) : ViewModelProvider.Factory {\n        override fun <T : ViewModel> create(modelClass: Class<T>): T {\n            if (modelClass.isAssignableFrom(WeatherViewModel::class.java)) {\n                @Suppress("UNCHECKED_CAST")\n                return WeatherViewModel(WeatherRepository(apiService)) as T\n            }\n            throw IllegalArgumentException("Unknown ViewModel class")\n        }\n    }\n}