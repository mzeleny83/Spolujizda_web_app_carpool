from typing import List, Tuple\nfrom src.models import UserRequest\nfrom src.utils import haversine_distance, time_difference_minutes\n\nclass MatchingEngine:\n    """\n    Core engine for finding carpool matches among a list of user requests.\n    """\n    def __init__(self, user_requests: List[UserRequest], distance_radius_km: float, time_tolerance_minutes: float):\n        self.user_requests = user_requests\n        self.distance_radius_km = distance_radius_km\n        self.time_tolerance_minutes = time_tolerance_minutes\n\n    def find_matches(self) -> List[Tuple[UserRequest, UserRequest, float, float, float]]:\n        """\n        Finds potential carpool matches based on geographical proximity of start/end\n        points and temporal proximity of departure times.\n\n        A match is suggested if:\n        1. The straight-line (Haversine) distance between their start points\n           is within `distance_radius_km`.\n        2. The straight-line (Haversine) distance between their end points\n           is within `distance_radius_km`.\n        3. The absolute difference in their departure times is within\n           `time_tolerance_minutes`.\n\n        Returns a list of tuples, where each tuple contains:\n        (UserRequest1, UserRequest2, start_distance_km, end_distance_km, time_difference_minutes)\n        """\n        matches = []\n        num_users = len(self.user_requests)\n\n        print(f"\
Analyzing {num_users} user requests for potential matches...")\n\n        # Iterate through all unique pairs of users to find matches\n        for i in range(num_users):\n            for j in range(i + 1, num_users): # Start from i+1 to avoid self-matching and duplicate pairs\n                user1 = self.user_requests[i]\n                user2 = self.user_requests[j]\n\n                # 1. Check proximity of start points\n                dist_start = haversine_distance(\n                    user1.start_lat, user1.start_lon,\n                    user2.start_lat, user2.start_lon\n                )\n                if dist_start > self.distance_radius_km:\n                    continue # Start points are too far apart, no match\n\n                # 2. Check proximity of end points\n                dist_end = haversine_distance(\n                    user1.end_lat, user1.end_lon,\n                    user2.end_lat, user2.end_lon\n                )\n                if dist_end > self.distance_radius_km:\n                    continue # End points are too far apart, no match\n\n                # 3. Check proximity of departure times\n                time_diff = time_difference_minutes(user1.departure_time, user2.departure_time)\n                if abs(time_diff) > self.time_tolerance_minutes:\n                    continue # Departure times are too far apart, no match\n\n                # If all conditions are met, a potential match is found\n                matches.append((user1, user2, dist_start, dist_end, time_diff))\n                print(f"  Potential match found between {user1.id} and {user2.id}.")\n\n        return matches\n